---
title: "Clase 5"
author: "Amaury Gutiérrez"
date: "4/15/2018"
output: html_document
---

## ¿Qué aprendimos la clase pasada?
* Se aprendió a usar el operador pipe %>%
* Se mostró el concepto de hacer joins entre tablas
* Lectura de datos en R (excel)
* Breve introdución a los datos faltantes

### Funciones en R

Las funciones permiten la automatización de tareas. La escritura de funciones tiene tres grandes ventajas:

* Puedes nombrar una función de una manera tal que nunca olvides qué hace, esto además hace a tu código más legible
* Cuando cambien los requerimientos de los trabajos día a día, deberás de modificar menos código.
* Se reduce la probabilidad de cometer errores llevando a cabo procesos manuales como copiar/pegar datos e instrucciones.

Aprender a escrbir buenas funciones es un proceso que nunca termina. Siempre se encontrarán maneras novedosas de mejorar estilos a la hora de escribir funciones. Esta sección no tiene como objetivo profundizar en la escritura de funciones, si no empezar a escribir funciones útiles lo más pronto posible. 

#### ¿Cuándo me conviene escribir funciones?

Como regla de dedo, si notas que para llevar a cabo una cierta tarea en R estás copiando y pegando un bloque de código más de dos veces, es hora de escribir una función para ello.

Por ejemplo sabemos que para calcular el área de un círculo se puede utilizar siempre la misma fórmula. Lo único cambiante es el radio del círculo de interés. Si escribimos una función en R que permita llevar a cabo este cálculo podremos usarla en cualquier momento.

Como un primer ejemplo escribamos una función que permita calcular el área de un círculo.

#### Escribiendo funciones en R

Pasos para crear una función:

* Elegir un nombre apropiado
* Pensar en qué hace y cuántos argumentos necesita para ejecutarse
* Traducir lo que queremos que haga a código de R dentro de un bloque asociado a una función y a los argumentos anteriores

Pensando en estos pasos decidamos que nuestra función se llame area_circulo() (sin acento, es en general, mala práctica utilizar caractéres especiales en código). Luego sabemos que la función recibe un único parámetro, el radio del círculo al que se le va a calcular el área. Finalmente se debe plazmar la fórmula para el cálculo del área de un círculo en R.

```{r}

# nombre ------------- argumentos
area_rectangulo    <- function(base, altura)

# aquí inicia el cuerpo de la función   
{
  
  # operamos sobre el radio del círculo
  area_calculada <- base * altura
  
  # regresamos el resultado (esto es lo que se asigna después de aplicar esta función)
  return(area_calculada)
  
}
# aquí termina el cuerpo de la función


# probemos nuestra función para un círculo de tamaño 10 unidades
area_resultante <- area_rectangulo(base=10, altura=7)

area_resultante
```

Dentro de una función pueden colocarse cualquiera de los elementos que se han visto en las clases pasadas. Por ejemplo se pueden incluir expresiones condicionales e incluso se pueden incluir otras funciones.

Por poner un ejemplo, escribamos una función que use la función anterior, pero que con una expresión condicional cheque si el vector de entrada ya está escalado (entre 0 y 1).

Las expresiones condicionales tiene la forma 

si { expresión } entonces

si no entonces

Esto es, checa si "expresión" es VERDADERA y si lo es, ejecuta el correspondiente bloque de código. Si expresión es falsa, ejecuta otro bloque de código o nada.

Por ejemplo, no tiene sentido pensar en radios de círculos de magnitud negativa. Para nuestra mala fortuna la fórmula del círculo elimina el efecto de un radio negativo y calcula una misma área para un radio independiéntemente si es positivo o negativo. 

Aún así, como ejemplo, introduciremos una expresión condicional que permita "atrapar" radios negativos y que nos de un aviso de que algo anda raro cuando esto suceda.

```{r}

# nombre ------------- argumentos
area_circulo    <- function(radio)

# aquí inicia el cuerpo de la función   
{
  # expresión condicional (si TRUE se ejecuta)
  if (radio<0)
  {
    print("No se permiten radios negativos")
  }
  # sigue la expresión condicional (esto se ejecuta cuando FALSE)
  else
  {
    # operamos sobre el radio del círculo
    area_calculada <- pi * radio^2
  
    # regresamos el resultado (esto es lo que se asigna después de aplicar esta función)
    return(area_calculada)
  }
  
}
# aquí termina el cuerpo de la función


# probemos nuestra función para un círculo de tamaño 10 unidades
area_resultante <- area_circulo(radio=-10)

area_resultante
```

![](./imagenes/manicule2.jpg) Ejercicio: escribir una función análoga a la anterior pero para calcular el área de un rectángulo. Tampoco debe permitir parámetros negativos.

Siguiendo con lo aprendido en clases pasadas podemos crear otra función que calcule el volumen de una 

![](./imagenes/volume.png)

```{r}

volumen_regular <- function(base, altura) {
  volumen <- base * altura
  return(volumen)
}

```


Hint: recordar que expresiones condicionales se pueden agregar con las operaciones "y" en R "&" y "o" en R "|".

#### un ejemplo más complejo y una introducción más formal a data.frames y tibbles

##### data.frames

Un data.frame se utiliza para almacenar tablas de datos. Es una lista de vectores de la misma longitud. Pueden ser de distintos tipos. Se puede pensar a los data.frames como las tablas de datos que se utilizan en excel. Siempre son matrices donde se accede a las celdas a través de coordenadas de la forma (rango de números para las filas , rango de letras para las columnas). En R se accede a las celdas utilizando las funciones vistas anteriormente y de manera más básica a través de coordenadas de la forma (rango de números para las filas , rango de números para las columnas).

Revisemos esto con base en un data.frame artificial que generaremos.

La primera columna es el resultado de generar de manera aleatoria 5 números a partir de una distribución normal estándar. Pueden checar el funcionamiento de ?rnorm para entender cómo se utiliza, se permite simular a partir de normales con los parámetros de nuestro elección, y tantas veces como queramos (en nuestro caso 10 veces para cada columna).

La segunda columna es simplemente un vector con valores booleanos.

La tercera tiene elementos texto que representan nombres.

```{r}

nuestro_df <- data.frame(
  
  # nombre de la columna --- # vector de datos
  normal_estandar = rnorm(5),
  booleano = c(TRUE,TRUE,FALSE,TRUE,FALSE),
  perritos = c("Pancho","Juana","Frijol","Fido","puppie")
)

View(nuestro_df)

```

Como se mencionó se puede acceder a las celdas de nuestro_df con coordenadas de la forma (rango de números para las filas , rango de números para las columnas).

Observación importante, en los data.frames las columnas se pueden elegir con números o con su nombre. Dejar una de las dimensiones de vacías indica que se elige todo lo disponible en esa dimensión. 

![](./imagenes/manicule2.jpg) Ejercicio: Ejecutar una por una las siguientes maneras de acceder a partes de nuestro_df y poner atención a cómo se comportan.

```{r,eval=FALSE}

# elegir el elemento de la primera fila y la primera columna de nuestro_df
nuestro_df[1,1]

# elegir los elementos de todas las filas y todas las columnas de nuestro_df
nuestro_df[,]

# elegir todos los elementos de la primer columna de nuestro_df
nuestro_df[,1]

# elegir todos los elementos de la primer columna de nuestro_df
nuestro_df[[1]]

# elegir todos los elementos de la primer columna de nuestro_df
nuestro_df[,"normal_estandar"]

# elegir todos los elementos de la primera y tercera columna de nuestro_df
nuestro_df[,c("normal_estandar","perritos")]

# elegir todos los elementos de la primera y tercera columna de nuestro_df
nuestro_df[,c(1,3)]

# elegir todos los elementos de la primera, segunda y tercera columna de nuestro_df
nuestro_df[,c(1,2,3)]

# elegir todos los elementos de la primera, segunda y tercera columna de nuestro_df
nuestro_df[,1:3]

# elegir todos los primeros 3 elementos de la primera, segunda y tercera columna de nuestro_df
nuestro_df[1:3,1:3]

```

Una vez que se elige una columna, esta se puede tratar como un vector. Como este tiene una sola dimensión entonces acceder a las celdas se hace teniendo esto en mente.

Por ejemplo, sobre el vector de nombres de perritos se puede hacer lo siguiente para obtener sólo los primeros tres nombres.


```{r}

# elegimos el vector de nombres de perritos y lo asignamos a un nuevo objeto

vector_perritos <- nuestro_df[,"perritos"]

# elegimos sólo los primeros tres nombres
vector_perritos[1:3]

```

Se observa que data.frame tiene como comportamiento default convertir vectores texto en variables categóricas, en R "factores". Esto es un comportamiento hoy en día poco deseado y se evita colocando en la instrucción que genera el data.frame, esto es la función data.frame(), el parámetro stringsToFactors=FALSE. 

Esto es tan poco popular que la versión más moderna de los data.frames, llamados tibbles (y que hemos venido usando), tiene esto apagado por default.

##### tibbles

Las "tibbles" simplemente son data.frames que han sido modificados para hacer nuestra vida, sobretodo utilizando el tidyverse, un poco más fácil.

Para convertir un data.frame en un tibble basta con utilizar la función (todo esto en realidad pertenece al paquete tibble) 

as_tibble()

```{r}

library("tidyverse")

# convertimos nuestro_df a un tibble y lo asignamos al objeto nuestro_tibble
nuestro_tibble <- as_tibble(nuestro_df)

nuestro_tibble

```

Como se puede observar, algo default de un tibble es que a la hora de consultarlo indica la naturaleza de cada una de las columnas.

Para acceder a la información de las tibbles se recomienda utilizar las funciones que se han venido enseñando hasta la fecha (en las clasese de transformación y manipulación de datos).

Si se quiere acceder crudamente a las celdas de objetos tibble se puede utilizar sintaxis análoga a la vista en la subsección anterior pero usando un pipe y colocando un punto, llamado placeholder, antes del corte de nuestra tabla de datos.


```{r}

# elegir el elemento de la primera fila y la primera columna de nuestro_df
nuestro_df[1,1]
nuestro_tibble  %>% .[1,1]

# elegir todos los elementos de la primer columna de nuestro_df
nuestro_df[[1]]
nuestro_tibble  %>% .[[1]]

# elegir todos los elementos de la primera, segunda y tercera columna de nuestro_df
nuestro_df[,1:3]
nuestro_tibble  %>% .[,1:3]

# elegir todos los primeros 3 elementos de la primera, segunda y tercera columna de nuestro_df
nuestro_df[1:3,1:3]
nuestro_tibble  %>% .[1:3,1:3]

```

##### Un ejemplo más complejo de uso de funciones

Como un ejemplo más complejo de uso de funciones, generemos otrra tabla de datos artificial. Esto es un data.frame donde cada columna es el resultado de generar de manera aleatoria 10 números a partir de una distribución normal estándar.

```{r}

library("tidyverse")

df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))

```

¿Alguien puede decir qué proceso se llevó a cabo sobre cada una de las columnas? Más aún, existe un error en uno de los pasos de este proceso ¿alguien puede identificar cuál es?

Escribir una función que lleve a cabo este proceso para después aplicarlo a cada una de estas cuatro columnas es la mejor manera de evitar errores como el anterior.

Lo primero que se necesita para escribir una función es pensar en qué queremos que haga, seguido de pensar en cuántos argumentos requiere.

El proceso anterior actúa sobre una columna de nuestra tabla de datos y no requiere de nada más que una de estas columnas para llevarse a cabo. 

Nosotros queremos escribir una función que escale un vector de datos (por ejemplo la columna de un data frame). Esto se logra restándole el mínimo y dividiendo entre el rango del mismo a cada una de sus entradas. Llamemos a la función "estandarizar":

```{r}

# nombre ------------- argumentos
estandarizar    <- function(vector)

# aquí inicia el cuerpo de la función   
{
  
  # operamos sobre el vector
  vector <- (vector - min(vector, na.rm = TRUE)) / 
  (max(vector, na.rm = TRUE) - min(vector, na.rm = TRUE))
  
  # regresamos el resultado (esto es lo que se asigna después de aplicar esta función)
  return(vector)
  
}
# aquí termina el cuerpo de la función


# probemos nuestra función
a_estandarizada <- estandarizar(df$a)

a_estandarizada


```

Recordando que dentro de una función pueden colocarse cualquiera de los elementos que se han visto en las clases pasadas. Por ejemplo expresiones condicionales, vamos a incluir en la función anterior código que cheque si el vector que se va a estandarizar, lo está ya, para no realizar la operación de nuevo si no se necesita. 


```{r}

library("tidyverse")

df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

# nombre ------------- argumentos
estandarizar_check    <- function(vector)

# aquí inicia el cuerpo de la función   
{
  
  # expresión condicional: ¿ya está entre 0 y 1 el vector de entrada?
  
  if (0<=min(vector) & max(vector)<=1)
  {
    # avísame si ya está estandarizado
    print("Ya está estandarizado, no hice nada")
  }
  else
  {
    # avísame si no lo está
    print("No está estandrizado, lo estandarizo")
    
    # operamos sobre el vector
    vector <- (vector - min(vector, na.rm = TRUE)) / 
    (max(vector, na.rm = TRUE) - min(vector, na.rm = TRUE))
  
  }
  
  # regresamos el resultado (esto es lo que se asigna después de aplicar esta función)
  return(vector)
}
# aquí termina el cuerpo de la función


# probemos nuestra función
a_estandarizada <- estandarizar_check(df$a)

a_estandarizada <- estandarizar_check(a_estandarizada)


```

Ahora que ya tengo una función que hace lo que quiero, puedo ejecutar de manera más sucinta y con menos posibilidad de errores lo que quería en un principio, que era estandarizar cada columna de nuestro data frame (df).

```{r}


df$a <- estandarizar_check(df$a)


```